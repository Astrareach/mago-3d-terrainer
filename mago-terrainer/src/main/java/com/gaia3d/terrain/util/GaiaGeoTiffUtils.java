package com.gaia3d.terrain.util;

import com.gaia3d.command.GlobalOptions;
import com.gaia3d.terrain.structure.GeographicExtension;
import com.gaia3d.util.CelestialBody;
import com.gaia3d.util.GlobeUtils;
import org.geotools.coverage.grid.GridCoordinates2D;
import org.geotools.coverage.grid.GridCoverage2D;
import org.geotools.geometry.jts.JTS;
import org.geotools.referencing.CRS;
import org.geotools.referencing.crs.DefaultGeographicCRS;
import org.joml.Vector2d;
import org.locationtech.jts.geom.Coordinate;
import org.locationtech.jts.geom.Geometry;
import org.locationtech.jts.geom.GeometryFactory;
import org.locationtech.jts.geom.Point;
import org.geotools.api.coverage.grid.GridEnvelope;
import org.geotools.api.coverage.grid.GridGeometry;
import org.geotools.api.geometry.Position;
import org.geotools.api.geometry.Bounds;
import org.geotools.api.referencing.FactoryException;
import org.geotools.api.referencing.ReferenceIdentifier;
import org.geotools.api.referencing.crs.CoordinateReferenceSystem;
import org.geotools.api.referencing.crs.GeographicCRS;
import org.geotools.api.referencing.operation.MathTransform;
import org.geotools.api.referencing.operation.TransformException;

public class GaiaGeoTiffUtils {
    public static Vector2d getLongitudeLatitudeDegree(GridCoverage2D coverage, int coordX, int coordY, GeometryFactory gf, MathTransform targetToWgs) throws TransformException {
        GridCoordinates2D coord = new GridCoordinates2D(coordX, coordY);
        Position p = coverage.getGridGeometry().gridToWorld(coord);
        Point point = gf.createPoint(new Coordinate(p.getOrdinate(0), p.getOrdinate(1)));
        Geometry wgsP = JTS.transform(point, targetToWgs);
        Point centroid = wgsP.getCentroid();
        Coordinate coordinate = centroid.getCoordinate();
        return new Vector2d(coordinate.x, coordinate.y);
    }

    public static boolean isGridCoverage2DWGS84(GridCoverage2D coverage) throws FactoryException {
        // this function returns true if the coverage is wgs84
        CoordinateReferenceSystem crsTarget = coverage.getCoordinateReferenceSystem2D();
        CoordinateReferenceSystem crsWgs84 = DefaultGeographicCRS.WGS84;
        MathTransform targetToWgs = CRS.findMathTransform(crsTarget, crsWgs84);
        // The original src is wgs84
        // The original src is not wgs84
        return targetToWgs.isIdentity();
    }

    private static CelestialBody detectCelestialBody(CoordinateReferenceSystem crs) {
        try {
            String crsName = crs.getName().getCode().toLowerCase();
            String wkt = crs.toWKT();

            // Check for lunar indicators
            if (crsName.contains("moon") || crsName.contains("lunar") ||
                wkt.contains("Moon") || wkt.contains("Lunar")) {
                // Verify by checking for lunar radius (1737400m)
                if (wkt.contains("1737400")) {
                    return CelestialBody.MOON;
                }
            }

            // Check CRS code identifiers
            for (ReferenceIdentifier id : crs.getIdentifiers()) {
                String code = id.getCodeSpace() + ":" + id.getCode();
                if (code.equals("IAU:30100")) {
                    return CelestialBody.MOON;
                }
                if (code.equals("EPSG:4326")) {
                    return CelestialBody.EARTH;
                }
            }

            // Default to Earth for compatibility
            return CelestialBody.EARTH;
        } catch (Exception e) {
            // Silently default to Earth for backward compatibility
            return CelestialBody.EARTH;
        }
    }

    public static void getBoundsSpanInMetersOfGridCoverage2D(GridCoverage2D coverage, double[] resultBoundsSpanMeters) throws FactoryException {
        CoordinateReferenceSystem crs = coverage.getCoordinateReferenceSystem2D();

        // Check if CRS is geographic (not just WGS84)
        if (crs instanceof GeographicCRS) {
            // Detect celestial body from CRS
            CelestialBody body = detectCelestialBody(crs);

            Bounds envelope = coverage.getEnvelope();
            double minLat = envelope.getMinimum(1);
            double maxLat = envelope.getMaximum(1);
            double midLat = (minLat + maxLat) / 2.0;

            // Use radius for detected celestial body
            double radius = GlobeUtils.getRadiusAtLatitude(midLat, body);
            double degToRadFactor = GlobeUtils.DEGREE_TO_RADIAN_FACTOR;

            double envelopeSpanX = envelope.getSpan(0);
            double envelopeSpanY = envelope.getSpan(1);
            resultBoundsSpanMeters[0] = (envelopeSpanX * degToRadFactor) * radius;
            resultBoundsSpanMeters[1] = (envelopeSpanY * degToRadFactor) * radius;
        } else {
            // Projected CRS - already in meters
            Bounds envelope = coverage.getEnvelope();
            resultBoundsSpanMeters[0] = envelope.getSpan(0);
            resultBoundsSpanMeters[1] = envelope.getSpan(1);
        }
    }

    public static Vector2d getPixelSizeMeters(GridCoverage2D coverage) throws FactoryException {
        double[] envelopeSpanInMeters = new double[2];
        getBoundsSpanInMetersOfGridCoverage2D(coverage, envelopeSpanInMeters);
        GridGeometry gridGeometry = coverage.getGridGeometry();
        int gridSpanX = gridGeometry.getGridRange().getSpan(0);
        int gridSpanY = gridGeometry.getGridRange().getSpan(1);
        double pixelSizeX = envelopeSpanInMeters[0] / gridSpanX;
        double pixelSizeY = envelopeSpanInMeters[1] / gridSpanY;
        return new Vector2d(pixelSizeX, pixelSizeY);
    }

    public static GeographicExtension getGeographicExtension(GridCoverage2D coverage, GeometryFactory gf, MathTransform targetToWgs, GeographicExtension resultGeoExtension) throws TransformException {
        // get geographic extension
        GridEnvelope gridRange2D = coverage.getGridGeometry().getGridRange();
        Bounds envelope = coverage.getEnvelope();

        double minLon = 0.0;
        double minLat = 0.0;
        double maxLon = 0.0;
        double maxLat = 0.0;

        // check if crsTarget is wgs84
        if (targetToWgs.isIdentity()) {
            // The original src is wgs84
            minLon = envelope.getMinimum(0);
            minLat = envelope.getMinimum(1);
            maxLon = envelope.getMaximum(0);
            maxLat = envelope.getMaximum(1);
        } else {
            GridGeometry originalGridGeometry = coverage.getGridGeometry();

            int gridSpanX = originalGridGeometry.getGridRange().getSpan(0);
            int gridSpanY = originalGridGeometry.getGridRange().getSpan(1);

            // gridLow0, gridLow1
            Vector2d lonLatLeftUp = GaiaGeoTiffUtils.getLongitudeLatitudeDegree(coverage, 0, gridSpanY - 1, gf, targetToWgs);

            // gridHigh0, gridHigh1
            Vector2d lonLatRightDown = GaiaGeoTiffUtils.getLongitudeLatitudeDegree(coverage, gridSpanX - 1, 0, gf, targetToWgs);

            // gridLow0, gridHigh1
            Vector2d lonLatLeftDown = GaiaGeoTiffUtils.getLongitudeLatitudeDegree(coverage, 0, 0, gf, targetToWgs);

            // gridHigh0, gridLow1
            Vector2d lonLatRightUp = GaiaGeoTiffUtils.getLongitudeLatitudeDegree(coverage, gridSpanX - 1, gridSpanY - 1, gf, targetToWgs);

            minLon = Math.min(lonLatLeftUp.x, lonLatRightDown.x);
            minLon = Math.min(minLon, lonLatLeftDown.x);
            minLon = Math.min(minLon, lonLatRightUp.x);

            maxLon = Math.max(lonLatLeftUp.x, lonLatRightDown.x);
            maxLon = Math.max(maxLon, lonLatLeftDown.x);
            maxLon = Math.max(maxLon, lonLatRightUp.x);

            minLat = Math.min(lonLatLeftUp.y, lonLatRightDown.y);
            minLat = Math.min(minLat, lonLatLeftDown.y);
            minLat = Math.min(minLat, lonLatRightUp.y);

            maxLat = Math.max(lonLatLeftUp.y, lonLatRightDown.y);
            maxLat = Math.max(maxLat, lonLatLeftDown.y);
            maxLat = Math.max(maxLat, lonLatRightUp.y);
        }

        if (resultGeoExtension == null) {
            resultGeoExtension = new GeographicExtension();
        }

        resultGeoExtension.setDegrees(minLon, minLat, 0.0, maxLon, maxLat, 0.0);
        return resultGeoExtension;
    }

    public static GeographicExtension getGeographicExtension_original(GridCoverage2D coverage, GeometryFactory gf, MathTransform targetToWgs, GeographicExtension resultGeoExtension) throws TransformException {
        // get geographic extension
        GridEnvelope gridRange2D = coverage.getGridGeometry().getGridRange();
        Bounds envelope = coverage.getEnvelope();

        double minLon = 0.0;
        double minLat = 0.0;
        double maxLon = 0.0;
        double maxLat = 0.0;

        // check if crsTarget is wgs84
        if (targetToWgs.isIdentity()) {
            // The original src is wgs84
            minLon = envelope.getMinimum(0);
            minLat = envelope.getMinimum(1);
            maxLon = envelope.getMaximum(0);
            maxLat = envelope.getMaximum(1);
        } else {
            int gridLow0 = gridRange2D.getLow(0);
            int gridLow1 = gridRange2D.getLow(1);
            int gridHigh0 = gridRange2D.getHigh(0);
            int gridHigh1 = gridRange2D.getHigh(1);

            // gridLow0, gridLow1
            Vector2d lonLatLeftUp = GaiaGeoTiffUtils.getLongitudeLatitudeDegree(coverage, gridLow0, gridLow1, gf, targetToWgs);

            // gridHigh0, gridHigh1
            Vector2d lonLatRightDown = GaiaGeoTiffUtils.getLongitudeLatitudeDegree(coverage, gridHigh0, gridHigh1, gf, targetToWgs);

            // gridLow0, gridHigh1
            Vector2d lonLatLeftDown = GaiaGeoTiffUtils.getLongitudeLatitudeDegree(coverage, gridLow0, gridHigh1, gf, targetToWgs);

            // gridHigh0, gridLow1
            Vector2d lonLatRightUp = GaiaGeoTiffUtils.getLongitudeLatitudeDegree(coverage, gridHigh0, gridLow1, gf, targetToWgs);

            minLon = Math.min(lonLatLeftUp.x, lonLatRightDown.x);
            minLon = Math.min(minLon, lonLatLeftDown.x);
            minLon = Math.min(minLon, lonLatRightUp.x);

            maxLon = Math.max(lonLatLeftUp.x, lonLatRightDown.x);
            maxLon = Math.max(maxLon, lonLatLeftDown.x);
            maxLon = Math.max(maxLon, lonLatRightUp.x);

            minLat = Math.min(lonLatLeftUp.y, lonLatRightDown.y);
            minLat = Math.min(minLat, lonLatLeftDown.y);
            minLat = Math.min(minLat, lonLatRightUp.y);

            maxLat = Math.max(lonLatLeftUp.y, lonLatRightDown.y);
            maxLat = Math.max(maxLat, lonLatLeftDown.y);
            maxLat = Math.max(maxLat, lonLatRightUp.y);
        }

        if (resultGeoExtension == null) {
            resultGeoExtension = new GeographicExtension();
        }
        resultGeoExtension.setDegrees(minLon, minLat, 0.0, maxLon, maxLat, 0.0);

        return resultGeoExtension;
    }

    public static GeographicExtension getGeographicExtension_v2(GridCoverage2D coverage, GeometryFactory gf, MathTransform targetToWgs, GeographicExtension resultGeoExtension) throws TransformException {
        // get geographic extension
        double lonMin = coverage.getEnvelope().getMinimum(0);
        double lonMax = coverage.getEnvelope().getMaximum(0);
        double latMin = coverage.getEnvelope().getMinimum(1);
        double latMax = coverage.getEnvelope().getMaximum(1);

        Point pointMin = gf.createPoint(new Coordinate(lonMin, latMin));
        Geometry wgsPMin = JTS.transform(pointMin, targetToWgs);

        Point pointMax = gf.createPoint(new Coordinate(lonMax, latMax));
        Geometry wgsPMax = JTS.transform(pointMax, targetToWgs);

        if (resultGeoExtension == null) {
            resultGeoExtension = new GeographicExtension();
        }
        resultGeoExtension.setDegrees(wgsPMin.getCentroid().getCoordinate().x, wgsPMin.getCentroid().getCoordinate().y, 0.0, wgsPMax.getCentroid().getCoordinate().x, wgsPMax.getCentroid().getCoordinate().y, 0.0);
        return resultGeoExtension;
    }
}
